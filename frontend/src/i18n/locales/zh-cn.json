{
  "Home": {
    "header": "发送隐形付款",
    "description": "只有汇款人和收款人知道谁收到了资金",
    "Tutorial": {
      "tutorial": "教程",
      "receiving-funds": "接收资金",
      "receive-first": "使用<span class=\"text-bold\">注册</span>页配置您的帐户",
      "receive-second": "要求某人通过 Umbra 应用程序向您的地址、ENS 或 CNS 名称发送资金",
      "receive-third": "查看<span class=\"text-bold\">接收</span>页面以提取资金",
      "sending-funds": "发送资金",
      "send-first": "获取您要向其汇款的人员的地址、ENS 或 CNS 姓名",
      "send-second": "填写<span class=\"text-bold\">发送</span>页面上的表单"
    }
  },
  "Home-action-card": {
    "send": "发送",
    "send-description": "向其他用户发送资金",
    "receive": "接收",
    "receive-description": "查看和提取收到的资金",
    "setup": "注册",
    "setup-description": "注册您的帐户以接收资金"
  },
  "Header-Links": {
    "home": "主页",
    "FAQ": "常见问题",
    "contact": "联系"
  },
  "Base-Layout": {
    "settings": "设置",
    "dark-mode": "深色模式",
    "advanced-mode": "高级模式",
    "advanced-mode-description": "启用高级功能，如私钥导出、其他收件人 ID 选项和事件扫描设置。",
    "caution": "请谨慎使用！",
    "on": "开",
    "off": "关",
    "about": "简介",
    "built-by": "{0} 项目",
    "links": "更多"
  },
  "Address-Settings": {
    "advanced-mode-on": "高级模式已开启"
  },
  "Contact": {
    "contact": "联系",
    "paragraph": "阅读{0}以后仍有疑问？请随时与我们联系！您可能会在 Discord 上获得最快的响应。.",
    "faq": "常见问题",
    "discord": "{0} Discord",
    "join-us": "加入我们的",
    "twitter": "在 Twitter {0} Umbra",
    "follow": "跟随",
    "email": "在 {0} 给我们发电子邮件"
  },
  "Send": {
    "sending-disabled": "在我们执行系统维护时，通过 Umbra 发送已暂时禁用。请稍后再回来查看！",
    "send": "发送",
    "connect-your-wallet": "连接您的钱包以发送资金",
    "connect-wallet": "连接钱包",
    "recipient": "收件人的 ENS 名称或地址",
    "recipient-pkey": "使用收件人的标准公钥发送",
    "question-circle": "选中后，使用的公钥将是提供的以太坊地址的标准公钥。接收者必须将其帐户的私钥输入此应用程序才能提取资金。",
    "question-circle-warning": "除非您知道自己在做什么，不要使用此功能。",
    "learn-more": "了解更多",
    "select-token": "选择要发送的代币",
    "token": "代币",
    "amount": "汇款金额",
    "summary": "总结",
    "sending": "发送中",
    "fee": "Umbra 费",
    "fee-explain": "在 %{chainName} 上交易非常便宜，因此会收取少量费用以阻止垃圾信息。",
    "total": "总额",
    "max": "最大限额",
    "copy-payment-link": "复制付款链接",
    "enter-an-amount": "请输入金额",
    "enter-a-recipient": "请输入收款人",
    "select-a-token": "请选择代币",
    "send-at-least": "请最少发送",
    "amount-exceeds-balance": "钱包金额不足",
    "please-complete-form": "请填写表格",
    "wallet-not-connected": "钱包未连接",
    "umbra-fee-exceeds-balance": "需要的 Umbra 费用超过钱包金额"
  },
  "Receive": {
    "receive": "接收",
    "connect-your-wallet": "连接您的钱包以扫描收到的资金",
    "connect-wallet": "链接钱包",
    "need-signature": "此应用程序需要您的签名才能扫描您收到的资金",
    "scan-funds": "点击下方来扫描您收到的资金",
    "sign": "签名",
    "scan": "扫描",
    "scan-settings": "扫描设置",
    "start-end": "输入扫描事件时要使用的开始或结束块。空白起始块将从块零扫描，空白结束块将扫描到当前块。",
    "start-block": "开始块",
    "end-block": "结束块",
    "enter-prv-key": "输入扫描事件时要使用的私钥。空白私钥将使用从您的签名生成的私钥。",
    "prv-key": "私钥",
    "fetching": "在获取公告...",
    "scanning": "在扫描资金...",
    "wait": "这可能需要几分钟，具体取决于您的连接和设备。这是正常的 — 请耐心等待。"
  },
  "Setup": {
    "setup": "注册",
    "connect-wallet": "连接您的钱包以注册您的帐户",
    "generate-stealth": "生成和发布隐形密钥",
    "paragraph": "使用下面的按钮完成注册过程。这将导致您的钱包出现两个提示： <ol> <li> <span class=\"text-bold\">签署消息</span> 用于生成特定于 Umbra 的私钥对。这些密钥允许您安全地使用Umbra，而不会影响已连接钱包的私钥。您无需将这些密钥保存在任何地方！ </li> <li> <span class=\"text-bold\">提交交易</span> 将相应的公钥保存在链上，以便任何人都可以使用它们向您发送隐形付款。 </li> </ol>",
    "setup-account": "注册帐户",
    "complete": "注册完成!",
    "return-to-home": "您现在可以返回{0}发送或接收资金",
    "return-home": "主页"
  },
  "Error": {
    "error": "哎呀。这里什么都没有......"
  },
  "FAQ": {
    "faq": "常见问题",
    "intro": "介绍",
    "what-is-umbra": "什么是 Umbra?",
    "what-is-umbra-answer": "<p>Umbra 是以太坊的隐身地址协议。 这意味着它允许付款人将资金发送到新地址。 该地址由预期的接收者控制，但只有付款人和接收者知道这一点。 </p><p> 思考 Umbra 的一种方式是：想象一下，如果在有人向您发送资金之前，您向他们发送了一个全新的、从未使用过的地址。 只有发件人会知道您控制该地址，这为您的付款增加了一层隐私。 通过 Umbra 付款的工作方式类似，但不是交互式的——你不需要给别人一个新的地址，他们可以生成一个他们知道只有你才能访问的地址。</p>",
    "an-example": "你能给我举个例子吗？",
    "an-exmaple-answer": "<p>Alice 拥有一家企业，并聘请 Bob 为她分包。她同意为 Bob 的工作支付 1,000 Dai/周。 Bob 拥有 ENS 地址 <span class=\"code\">bob.eth</span>。 如果 Alice 每周将资金发送到 <span class=\"code\">bob.eth</span>，那么任何查看该链的人都可以容易知道 Alice 每周向 Bob 支付 1,000 Dai。</p><p>相反，Bob 和 Alice 将使用 Umbra 进行私人支付。 Bob 第一次访问 Umbra 应用程序时，他设置了自己的帐户，使任何人都可以使用他的地址私下向他付款。然后 Alice 每周使用 Umbra 向 Bob 发送 1,000 Dai ——她只需要知道他的地址或 ENS 名称。</p><p>在链上，我们可以看到 Alice 每周向一个新的空地址支付 1,000 Dai。在幕后，Bob 通过 Umbra 控制每个地址的密钥，但除了 Alice 和 Bob 之外没有人知道这一点。</p><p>Bob 每周使用 Umbra 提取他的 1,000 Dai。他只需要提供一个地址即可将其发送到。他最好使用与他的身份无关的地址。他通常选择直接将其发送到交易所，并根据需要将其出售为法定货币。重要的是，这意味着<strong> Bob 的交易所现在知道这笔款项是给他的</strong>。 对于不经意的链观察者——一个无法访问专有中心化交易所数据的人——Alice 的付款流向 Bob 的事实是掩盖的。</p><p> 再举一个例子：Liza 经营着一个请求捐款的网站。如果大家直接给她捐款，大家都会知道丽莎收到了多少捐款。如果改为使用 Umbra 发送捐款，则每笔捐款将被发送到不同的地址，只有 Liza 才能知道她收到的捐款总额。</p>",
    "wen-token": "Umbra 有代币吗？",
    "wen-token-answer": "没有。",
    "how-does-it-work": "它是如何工作的？",
    "how-does-it-work-answer": "<p>下面是对 Umbra 工作原理的简介：</p><ol><li>在设置您的 Umbra 帐户时，用户会签署一条消息。此消息的散列用于生成两个私钥: 一个“支出密钥”和一个“查看密钥”。 </li> <li>相应的公钥都作为与您的地址关联的记录在链上发布。</li><li>付款人使用您的地址或 ENS 名称来查找您的两个公钥。另外，付款人生成一个随机数。</li><li>随机数与支出公钥一起使用，以生成一个“隐形地址”来发送资金。与查看公钥使用相同的随机数来加密随机数。</li><li> 使用 Umbra 合约，付款人将资金发送到隐身地址，加密数据作为 <span class=\"code\">Announcement</span>  事件发出。</li><li>接收方扫描 Umbra 合约中的所有 <span class=\"code\">Announcement</span> 事件。对于每个人，他们使用他们的查看密钥来解密随机数，然后将该数字乘以他们的支出密钥来生成隐形私钥。如果隐形私钥控制资金发送到的地址，则这笔款项是给收款人的。</li> <li> 接收方现在可以使用私钥直接将提取资金所需的交易发送到另一个地址，或者签署元交易以让中继器处理取款请求。</li></ol>",
    "how-does-it-work-see-the": "请参阅 {0} 部分了解更多详情。",
    "how-does-it-work-technical-dtails": "“技术细节：它是如何工作的？“",
    "how-private": "Umbra 有多私密？",
    "how-private-answer": "<p>Umbra 提供了一组有限的隐私保证，在使用协议之前了解它们很重要。 Umbra <span class=\"text-bold\">不像</span> Aztec 或 Zcash 那样提供“完整”隐私。 它只是让任何外部观察者（即任何不是发送者或接收者的人）都无法通过查看接收地址来知道发送者为谁付款。</p><p>重要的是要了解接收方的安全状况不佳（例如，将资金直接发送到公开地址）会消除发送方和接收方的隐私利益。</p><p>如果观察者可以缩小给定交易的潜在接收者的范围，Umbra 的隐私属性也可以被减少。任何有效的公钥都可以用作接收者，任何在以太坊上发送过交易的人都有一个公开的公钥。因此，默认情况下，“匿名集”——交易的潜在接收者的集合——是任何曾经发送过以太坊交易的人！</p><p>在实践中，情况不一定如此，观察者可以通过以下几种方式缩小收件人列表范围：</p><ol><li>大多数用户将使用 Umbra 隐形密钥注册表来发送资金，因此接收者很可能在其中发布了密钥。</li><li>从您的隐身地址提取资金时不小心会减少或使 Umbra 提供的隐私属性无效。请参阅“取款到哪个地址是安全的？”更多细节。取款时请务必小心！</li></ol>",
    "umbra-vs-mixer": "Umbra 是一个混币器吗？",
    "umbra-vs-mixer-answer": "<p> Umbra 不是一个混币器，也不使用零知识证明。相反，Umbra基于普通的椭圆曲线密码学。它适用于两者之间的交易，并带有一组不同的隐私权衡。Umbra 不会像混币器那样断开发送地址和接收地址之间的链接，而是使该链接变得毫无意义。每个人都可以看到谁发送了资金，每个人都可以看到资金被发送到的地址，但是该接收地址从未在链上出现过，因此任何外部观察者都不可能知道谁控制它。</p>",
    "account-setup": "帐户注册",
    "what-is-setup": "什么是账户注册？",
    "what-is-setup-answer": " <p> 用户签署一条消息，并从中生成 Umbra 公钥和私钥。 在 Umbra 隐形密钥注册表上进行交易，将公钥与您的地址相关联。</p>",
    "is-setup-required": "我是否需要注册帐户？",
    "is-setup-required-answer": " <p> 此步骤在技术上不是必需的，但出于安全原因强烈建议执行此步骤。 为了获取隐形资金，Umbra 应用程序需要您的私钥。 将您钱包的私钥输入任何网站都是非常危险的，我们不希望您这样做！ 通过完成帐户设置过程，您签署了一条消息以生成一组特定于应用程序的 Umbra 私钥。 这更加安全，因为 Umbra 从来没有您钱包的私钥。 </p>",
    "why-setup-again": "为什么我需要重新注册我的帐户？",
    "why-setup-again-answer": "<p> 如果您在服务仍处于测试阶段（2021 年 10 月之前）时配置了 Umbra 帐户，则需要重新设置。这需要一个签名和一个交易。 </p> <p> 这个额外的设置步骤是由于升级到 Umbra 的隐形密钥注册表系统。旧系统依赖于与用户地址关联的 ENS 解析器上的记录。新系统要简单得多，并使用用户地址和他们的隐秘密钥之间的简单映射。 </p> <p> 新系统是为了响应 Umbra Beta 期间的用户反馈而开发的。旧系统需要多次交易，还要求发送方使用接收方的 ENS 名称，造成困惑。新系统只需要一次交易，发送者可以提供接收者的 ENS 名称或他们的常规以太坊地址。总体而言，新系统的配置和使用都更简单。 </p>",
    "why-setup-again-answer-issue": "有关此升级的更深入和技术说明，请参阅 Umbra 的 Github 存储库上的 {0}。",
    "why-setup-again-answer-this-issue": "此问题",
    "sending-funds": "汇款",
    "why-only-tokens": "为什么只有某些代币可用？",
    "why-only-tokens-answer": "<p> 当您发送 ETH 时，ETH 会直接发送到计算出的隐身地址。该隐身地址现在有 ETH，需要支付 gas，因此接收方可以通过普通发送轻松转移该 ETH。 </p> <p> 当您发送代币时，代币不会直接发送到计算出的隐身地址。如果是这样，您首先需要将 ETH 放入隐身地址，以便支付提取资金的 gas（或使用一些昂贵的 CREATE2 方案）。相反，代币由合约持有，可以通过以下两种方式之一释放： </p> <ol> <li>隐身地址直接调用 <span class=\"code\">withdrawToken()</span> 方法</li> <li> 任何人调用 <span class=\"code\">withdrawTokenOnBehalf()</span> 并从隐身地址传递一个签名。这使得元交易可以与您选择的中继器一起使用。 </li> </ol> <p> 默认情况下，Umbra 应用程序使用来自 Umbra 团队的中继器。管理中继器并确保正确报销交易费用可能会很棘手，因此一开始只启用了几个代币，并且支持的代币列表将被扩展。</p>",
    "when-receive": "收款人何时会收到他们的资金？",
    "when-receive-answer": "<p> 立即地！接收者在发送交易被挖掘后，立即收到并可以提取资金。 </p>",
    "min-amount": "为什么有最低发送金额？",
    "min-amount-answer": " <p> 当您使用 Umbra 汇款时，收款人地址是一个以前从未使用过的地址。这意味着它没有 ETH 和代币，因此它必须使用发送给它的资金来支付提款费用。发送 ETH 时，这是通过常规转账完成的。发送代币时，这是通过中继器完成的，因此可以使用收到的代币支付费用。因此，有最低发送金额，以确保收款人始终可以轻松提取资金。 </p>",
    "umbra-fee": "为什么有时会有 Umbra 费用？",
    "umbra-fee-answer": "<p> 您通过 Umbra 收到的资金需要扫描所有已发送的交易，然后检查每笔交易以找到属于您的交易。 </p> <p> 在交易费用非常便宜的网络上，Umbra 合约在发送资金交易时以阻止垃圾信息收取少量费用，因为垃圾信息会使扫描所有发送的交易变得更加困难。 </p>",
    "payment-links": "什么是支付链接？",
    "payment-links-answer": " <p> 在发送页面上，填写部分或全部发送表单，然后单击<span class=\"text-italic\">复制付款链接</span>按钮。这会将 URL 复制到剪贴板，当访问该剪贴板时，会使用 URL 中的值预先填充发送表单。 </p> <p> 指定金额作为付款链接的一部分时要小心，因为它会降低隐私。例如，如果您分享了一个支付链接，人们可以向您捐赠 100 DAI，突然间大量 100 DAI 开始通过 Umbra，观察者就会知道这些转账很可能是属于您的。 </p>",
    "receiving-funds": "收款",
    "safe-address": "提取资金到哪些地址是安全的？",
    "safe-address-answer": "<p> 我们建议以保护隐私的方式取款3 种方式。请注意，每个都有自己的权衡取舍。 </p> <ol> <li> 提取到与您的身份没有公开关联的地址（权衡：发件人现在可以推断您控制该地址） </li> <li> 生成一个新地址并提取到该地址（权衡：如果您收到了代币，则必须先用 ETH 为该地址注资，然后才能使用它们） </li> <li> 提取到交易所地址（权衡：如果你取款到 Coinbase，那么 Coinbase 会知道谁给您发了资金） </li> </ol>",
    "non-safe-address": "提取资金到哪些地址不安全？",
    "non-safe-address-answer": "<p> 取款时要考虑的风险是，如果您提取到与某些公开身份相关联的地址，那么隐私将丢失如下： </p> <p> 假设 Alice 通过 Umbra 向 Bob 发送资金。现在，只有 Alice 和 Bob 知道 Alice 付钱给 Bob。任何其他观察者都知道 Alice 向某人发送了资金，但他们不知道那个人是谁。 </p> <p> 如果 Bob 将这些资金提取到他公开的bob.eth地址，该地址解析为0x123...def，那么观察者知道发生了以下两件事之一： </p> <ol> <li>场景 1：Alice 向 Bob 发送资金，然后 Bob 将资金提取到他自己的地址，或者</li> <li>场景 2：Alice 向认识 Bob 的人发送资金，并从他们的隐身地址支付 Bob</li> </ol> <p> 此外，考虑 Bob 通过直接向他的朋友 Charlie 支付款项而取款的情况——Charlie 现在知道 Alice 向 Bob 支付了款项。 </p> <p>为了帮助缓解这种情况，如果您输入的提款地址可能会降低您的隐私，Umbra 应用程序会尝试警告您。因此，如果应用检测到您正在提款到以下地址，您会看到警告： </p> <ol> <li>有 ENS 或 CNS 名称</li> <li>拥有 POAP 代币</li> <li>是您登录的钱包</li> <li>（即将推出）：提取到对 Gitcoin 有贡献的地址。</li> </ol> <p> 这些<span class=\"text-bold\">不是</span>所有潜在危险提款地址的完整列表，因此请谨慎使用。 </p>",
    "umbra-withdrawal": "Umbra 能否以保护隐私的方式更轻松地提取资金？",
    "umbra-withdrawal-answer": "<p> 是的！这是我们打算在未来进行许多改进的领域，主要是依靠 Umbra 的提款后挂钩功能。 </p> <p>我们计划如何利用这一点的一些示例包括：</p> <ol> <li>以原子方式将一些代币交换为 ETH，并将其全部发送到新地址</li> <li>将资金直接提取到 DeFi 协议中</li> </ol> <p> 我们可以通过钩子追求许多其他选项，以极大地扩展隐私保护取款选项。 </p>",
    "scan-time": "为什么扫描我的资金需要这么长时间？",
    "scan-time-answer": "<p> 查找给您发送的付款时，该应用程序需要搜索每一笔发送过的付款并检查它是否属于您。因此，已发送的付款越多，所需的时间就越长。 </p>",
    "scan-time-answer-issue": "这是一个具有各种潜在解决方案的研究问题 ({one}{two})，我们希望随着时间的推移改进这一点。",
    "when-withdrawal": "我的资金何时可以提取？",
    "when-withdrawal-answer": "<p>立即地！您收到并可以在发送交易被挖掘后立即提取资金。</p>",
    "security": "安全",
    "audit": "Umbra 是否经过审核？",
    "audit-answer-contract": "这些{contracts}已通过 ConsenSys Diligence 审计，可在{here}查阅审计报告。",
    "audit-contracts": "合约",
    "audit-here": "这里",
    "audit-answer-umrba-js": " {umbra-js} {library} —负责处理所需的链下逻辑和椭圆曲线操作—已通过Least Authority审计，审计报告可查看 {here}。",
    "audit-library": "库",
    "audit-answer-umbra-off-chain": "链下椭圆曲线操作是 Umbra 业务逻辑的核心部分，所以我们依赖 {PaulMillers} 的简单，零依赖的 {noble-secp256k1} 库来处理。非常感谢{community}的帮助，我们能够筹集到足够的资金来支付Cure53 对该库进行审计的费用。您可以在{here}。",
    "audit-community": "社区",
    "umbra-risk": "Umbra 的风险是什么？",
    "umbra-risk-answer": "<p> 和其他货币生态系统中的软件一样，使用 Umbra 也存在风险。这包括严重的软件漏洞，黑客攻击、或其他恶意行为者攻击的风险。任何或所有这些情况都可能导致资金损失。 </p> <p>更具体地说，以下是我们过去在其他项目中看到的一些风险：</p> <ol> <li>合同漏洞使攻击者窃取合同资金或使资金冻结</li> <li>我们的链下代码中的一个错误导致资金被发送到一个不可恢复的地址</li> <li>DNS被劫持以窃取用户的私钥</li> <li>前端代码供应链攻击窃取用户私钥</li> </ol> <p> 我们正在努力防止这些风险，但这并不意味着我们会成功。Umbra 不提供任何担保，您应自担风险下使用它。 </p>",
    "crypto-js": "JavaScript 中的密码学是否安全？",
    "crypto-js-answer": "一般来说，JavaScript 执行环境并不适合满足安全要求。它在将秘密数据隐藏在内存中（例如，您的应用程序特定的私钥）和防止该数据写入磁盘方面提出了挑战。使用 JavaScript 还意味着底层加密库可能容易受到诸如 {timing-attacks}。 Umbra 使用 {noble-secp256k1} 进行所有加密，您可以阅读有关其限制和缓解此类漏洞的更多信息，看 {here}。",
    "crypto-js-timing-attacks": "定时攻击",
    "crypto-js-here": "这里",
    "crypto-js-answer-rest": "</p> <p> 然而，以太坊生态系统有许多依赖 JavaScript 密码术的钱包和应用程序，到目前为止还没有因此而出现重大问题，因此这种方法对于大多数用户来说可能是一个合适的折衷方案。 </p>",
    "tech-details": "技术细节",
    "network-addrs": "Umbra 部署在哪些网络上以及合约地址是什么？",
    "network-addrs-core": "核心 {umbra} 合约部署在 {umbra-addr} {mainnet}, {rinkeby}, {optimism}, {polygon}, 和 {arbitrum}",
    "network-addrs-registry": "{stealthRegistry} 部署在 {stealthRegistryAddr} {mainnet}, {rinkeby}, {optimism}, {polygon}, 和 {arbitrum}",
    "how-it-works": "它是如何工作的？",
    "how-it-works-answer": "<p class=\"text-bold\">隐形地址概述</p> <p>让我们从 Umbra 协议的工作原理（更一般地说，隐身地址的工作原理）开始：</p> <p> 接收者拥有公钥 <span class=\"code\">P</span> 和私钥 <span class=\"code\">p</span>。 发送者生成一个随机数 <span class=\"code\">r</span>，并使用椭圆曲线乘法计算隐身公钥为  <span class=\"code\">P_stealth = P * r</span> 。 发件人从该公钥中派生出以太坊地址 <span class=\"code\">a_stealth</span> ，并向其发送资金。由于椭圆曲线数学的魔力，接收者可以通过计算 <span class=\"code\">p_stealth</span> 生成访问 <span class=\"code\">a_stealth</span> 资金所需的私钥 <span class=\"code\">p_stealth = p * r</span>. </p> <p> 首先要解决的问题是发送方如何将值 <span class=\"code\">r</span> 传递给接收方？如果 <span class=\"code\">r</span> 是公开的，观察者可以通过计算 <span class=\"code\">P * r</span> 来确定向谁发送了各种已发布的 <span class=\"code\">P</span> 值，直到找到隐身地址。所以 <span class=\"code\">r</span> 需要加密。 </p>",
    "how-it-works-answer-ECDH": "加密完成 {ECDH} (ECDH)，这意味着发送者使用接收者的公钥来加密随机数。加密的随机数会给我们密文 {c}。加密的随机数 {c} 和隐身地址 {a-stealth} {announcement} 发出。ECDH 要求发送方生成用于加密的临时私钥，因此接收方需要解密的临时公钥 {P-ephemeral} 也会在此事件中发出。",
    "how-it-works-answer-part-2": "<p> 现在接收者可以扫描所有的 <span class=\"code\">Announcement</span> 事件并找到他们的资金，如下所示： </p> <ul> <li> 使用他们的私钥 <span class=\"code\">p</span> 和 <span class=\"code\">P_ephemeral</span>，他们可以计算 ECDH 共享密钥并解密随机数。 这总是会解密为 <span class=\"text-italic\">某些东西</span>，但我们还不知道它是否解密为正确的数字。 </li> <li> 所以接收方将解密后的随机数乘以 <span class=\"code\">p</span> 得到 <span class=\"code\">p_stealth</span>，并计算出 <span class=\"code\">p_stealth</span> 控制的地址</li> <li> 如果 <span class=\"code\">p_stealth</span> 控制的地址与公告中包含的  <span class=\"code\">a_stealth</span>  隐身地址匹配，则收件人知道付款是给他们的，并且可以使用 <span class=\"code\">p_stealth</span>取款。 </li> </ul> <p class=\"text-bold\">应用程序私钥</p> <p> 从上面的解释可以看出，该应用程序需要访问您的私钥才能执行所需的数学运算。但是，当您将钱包连接到应用程序时，钱包不会与应用程序共享您的私钥。这很好，因为如果您使用的任何应用程序都可以窃取您的资金！那么 Umbra 如何访问您的密钥呢？我们有几个选项： </p> <ol> <li> 要求用户将其钱包的私钥输入到表单中。从安全性和用户体验的角度来看，这都很糟糕，所以我们不这样做 </li> <li> 生成一个随机私钥并要求您备份它。这可行，但必须备份特定于应用程序的机密并不理想。 </li> <li>要求用户对消息进行签名，对签名进行哈希处理，并从签名中生成密钥。</li> </ol>",
    "how-it-works-answer-option-3": "选项 3 解决了选项 1 和 2 的问题，是我们的应用程序使用的方法。类似的方法被使用 {loopring} 和 {zksync} 同样，他们是这种方法的灵感来源。",
    "how-it-works-answer-end": "<p class=\"text-bold\">扫描资金</p> <p> 最后的考虑与扫描有关。因为需要扫描每一个 <span class=\"code\">Announcement</span> ，所以可能需要很长时间才能找到您的资金。 </p> <p> 一种加快速度的方法（从用户的角度来看）是将扫描委托给第三方服务，并让他们在您收到资金时通知您。但是扫描服务需要你的私钥 <span class=\"code\">p</span> 来确定你是否收到了资金，如果他们有 <span class=\"code\">p</span> 他们可以窃取你的资金！ </p> <p> 我们可以通过生成两个特定于应用程序的私钥来解决这个问题。一个私钥将是查看私钥 <span class=\"code\">p_view</span>，用于加密随机数。另一个是支出私钥  <span class=\"code\">p_spend</span>，用于计算隐形地址和访问这些资金。因此，我们的发送和接收流程现在稍微修改为： </p> <ol> <li> 接收人有两个私钥 <span class=\"code\">p_spend</span>  和 <span class=\"code\">p_view</span>，并发布对应的公钥 <span class=\"code\">P_spend</span> 和 <span class=\"code\">P_view</span>. </li> <li> 发送者生成一个随机数 <span class=\"code\">r</span> 并使用 <span class=\"code\">P_view</span> 和一个临时私钥  <span class=\"code\">p_ephemeral</span> 对其进行加密以生成密文 <span class=\"code\">c</span> </li> <li> 发件人将隐身地址计算为派生自 <span class=\"code\">P_stealth = P_spend * r</span> 的地址，并将资金发送到该地址 </li> <li> Umbra 合约发出 <span class=\"code\">c</span>, <span class=\"code\">P_ephemeral</span>，和隐身地址 <span class=\"code\">a_stealth</span> </li> <li> 对于每个事件，接收者使用 <span class=\"code\">p_view</span> 和 <span class=\"code\">P_ephemeral</span> 解密 <span class=\"code\">r</span>，然后检查 <span class=\"code\">p_stealth = p_spend * r</span> 是否是控制  a_stealth 的私钥</li> </ol> <p> 通过这种方法，收件人可以通过提供第三方 <span class=\"code\">p_view</span> 和 <span class=\"code\">P_spend</span>来接受扫描服务 。该服务现在可以检查收款人是否已收到资金但第三方没有花钱权利。 </p>",
    "spend-view-keys": "什么是消费和查看密钥？",
    "spend-view-keys-answer-1": "借用 {0} 来自 Zcash, Umbra 允许但不要求用户在“加密随机数”和“计算隐身地址”步骤中使用不同的私钥。这是 Umbra 应用程序的默认行为，但可以使用高级模式超控它。",
    "nomenclature": "命名法",
    "spend-view-keys-answer-2": "看 {0} 来了解更多关于消费和查看密钥如何工作的详细信息。",
    "spend-view-keys-technical-details": "”技术细节：它是如何工作的？“",
    "advanced-mode": "高级模式",
    "what-is-advanced": "什么是高级模式？",
    "what-is-advanced-answer": "<p> 对于了解协议、其工作原理以及所涉及风险的高级用户，您可能需要启用高级模式。这提供一系列附加功能，但使用不当可能会导致隐私减少或资金损失。谨慎使用！ </p>",
    "send-to-pkey": "如何通过地址或公钥向用户发送资金？",
    "send-to-pkey-answer": "<p> 只要用户在以太坊上至少发送了一笔交易，即使他们的地址没有设置Umbra账户，您也可以将资金发送到他们控制的隐蔽地址。这工作如下： </p> <ol> <li>启用高级模式</li> <li>导航到发送页面并连接您的钱包</li> <li>选中“使用收件人的标准公钥发送”框</li> <li>收件人字段通常只接受隐秘密钥注册表中的地址，并使用那里发布的公钥生成隐秘地址。但现在，它允许您输入任何地址，并使用该地址基础的标准公钥。它还将接受公钥、地址，甚至交易哈希！（使用交易哈希实际上与输入该交易的发件人地址相同）</li> <li>继续像往常一样发送资金</li> </ol> <p>请注意以这种方式发送资金时会产生以下权衡:</p> <ol> <li>此交易不使用单独的消费和查看密钥，并且每个使用相同的密钥</li> <li> 要从应用程序中提取资金，收款人必须启用高级模式并将其私钥手动粘贴到网站中。这是一个很大的牺牲，因此在以这种方式发送资金之前，请确保收款人对此表示同意。 </li> </ol>",
    "access-funds": "如何使用我的地址作为收款人标识符来访问发送给我的资金？",
    "access-funds-answer": "<p> 如果资金是通过直接使用您的公钥，您的地址或您发送的交易的交易哈希发送给您的，您的资金仍然可以被提取。 </p> <p>最安全的方法是在本地使用 <span class=\"code\">umbra-js</span> 包：</p> <ol> <li>使用 <span class=\"code\">yarn init</span> 设置本地 JavaScript 项目</li> <li>使用 <span class=\"code\">yarn add ethers @umbra/umbra-js</span> 安装 ethers.js 和 umbra -js</li> <li> 在您的脚本中，执行以下操作： <ol> <li>使用 ethers.js 连接到主网提供商</li> <li> 使用 <span class=\"code\">const umbra = new Umbra(provider, 1)</span> 初始化 Umbra class 实例</li> <li> 使用地址的私钥初始化 KeyPair 类的实例， <span class=\"code\">const keyPair = new KeyPair(myPrivateKey)</span> </li> <li> 使用 <span class=\"code\">umbra.scan()</span> 方法搜索您的资金。现在， <span class=\"code\">viewingPrivateKey</span> 输入由 <span class=\"code\">keyPair.privateKeyHex</span>给出，而 <span class=\"code\">spendingPublicKey</span> 输入由 <span class=\"code\">keyPair.publicKeyHex</span> 给出</li> <li> 对于每个 <span class=\"code\">Announcement</span>，您可以使用静态方法 <span class=\"code\" >Umbra.computeStealthPrivateKey(keyPair.privateKeyHex, announcement.randomNumber)</span > 来计算隐秘私钥 </li> </ol> </li> <li> 现在您拥有了隐秘私钥，您可以使用您喜欢的任何方法签署和中继提款交易。请参阅 Umbra class 中可能有帮助的各种提款方法。 </li> </ol> <p> 如果您更宁愿方便但不安全，您可以使用 Umbra 应用程序取款，但要小心——将您的私钥输入到任何网站绝不是一个好主意！如果您确实想走这条路： </p> <ol> <li>启用高级模式</li> <li>导航到接收页面并连接您的钱包</li> <li>扫描前，在表格中输入相应的私钥</li> <li>如果不需要，请将开始块和结束块字段留空</li> <li>点击“扫描”来扫描资金</li> </ol>",
    "scan-range": "如何仅扫描特定范围的块？",
    "scan-range-answer": "<p> 如果您大概知道何时收到资金，则可以加快仅查询特定区块范围内事件的扫描过程。去做这个：</p> <ol> <li>启用高级模式</li> <li>导航到接收页面并连接您的钱包</li> <li>扫描前，输入所需的开始和结束块号</li> <li>如果不需要，请将私钥字段留空</li> <li>点击“扫描”扫描资金</li> </ol> <p> 开始和结束块编号将保存在本地存储中，并在您下次使用高级模式扫描时自动应用。将两个字段留空以清除值并使用默认值。 </p>",
    "view-prvkey": "如何查看隐形私钥？",
    "view-prvkey-answer": "如果您想查看收到的某笔付款的隐秘私钥： <ol> <li>启用高级模式</li> <li>导航到接收页面并扫描资金</li> <li>对于尚未提现的交易，点击“提现”展开该行</li> <li> 您会看到“显示取款私钥”的文字，其中将显示取款所需的隐秘私钥 </li> </ol>",
    "for-developers": "对于开发者",
    "build-on-umbra": "如何在 Umbra 之上构建？",
    "build-on-umbra-answer": "<p> 开发人员文档尚未编写，但所有代码都经过了彻底的注释，因此阅读代码以了解事物的工作原理并在其之上构建应该很简单。 </p> <p> umbra-js 库是一个很好的起点，因为它可以让您全面了解 Umbra 的工作原理，并深入了解细节。之后，您可以查看合同并准确了解其适合的位置。 </p> <p> 下面应该是遍历 umbra-js 代码库的好顺序。如果您觉得这令人困惑，请让我们知道更好的顺序是什么！ </p> <ol> <li> <span class=\"code\">src/classes/Umbra.ts</span>: <span class=\"code\">Umbra</span> 类是供开发人员直接交互的高级类。它将协议的复杂性抽象为几个主要方法： <ol> <li> <span class=\"code\">send()</span> 用于向另一个用户发送资金，并自动处理所需的底层加密 </li> <li> <span class=\"code\">generatePrivateKeys()</span> 提示用户签名并生成他们的消费和查看密钥。 <span class=\"text-italic\"> 注意：确保使用的钱包支持确定性 ECDSA 签名 <a class=\"hyperlink\" href=%{link} target=\"_blank\">RFC 6979</a>. </span> </li> <li> <span class=\"code\">scan()</span> 让您通过仅提供用户的支出公钥并查看私钥来查找发送给指定用户的资金 </li> <li> <span class=\"code\">withdraw()</span> 让隐身地址直接提取代币和 ETH </li> <li> <span class=\"code\">withdrawOnBehalf()</span> 使用元交易来代表另一个用户中继一个取款交易，并且 <span class=\"code\">signWithdraw()</span> 方法用于获取所需的签名 </li> <li> <span class=\"code\">relayWithdrawOnBehalf()</span> 可用于使用默认的 Umbra 中继器中继元交易 </li> </ol> </li> <li> <span class=\"code\">src/classes/KeyPair.ts</span>：这个类是核心密码逻辑所在的地方。 <span class=\"code\">KeyPair</span> 类使用私钥或公钥进行实例化，类方法可帮助您使用这些密钥执行各种操作，包括公钥的加密/解密、乘法和压缩/解压缩 </li> <li> <span class=\"code\">src/classes/RandomNumber.ts</span>：这个简单的类用于生成我们的 32 字节随机数。 </li> <li> <span class=\"code\">src/utils/utils.ts</span> 包含用于一系列任务的各种辅助方法，主要与获取收件人的公钥有关 </li> <li> <span class=\"code\">src/types.ts</span>：您会看到一些自始至终使用的自定义类型，它们都在此处定义 </li> </ol> <p> 阅读完以上内容后，您应该已经准备好理解 Umbra.sol 合约，您会发现它实际上非常简单。合同中你还没有看到任何内容的新部分是钩子。您可以在“什么是 Hooks 以及如何使用它们”部分中了解更多相关信息。 </p>",
    "receive-vkey": "我怎样才能收到用户的查看密钥，而不是他们的消费密钥？",
    "receive-vkey-answer": "<p> 目前，唯一的方法是使用 <span class=\"code\">Umbra.generatePrivateKeys()</span>请求用户签名，这将返回他们的消费密钥和查看密钥。您可以丢弃支出密钥而不使用它。执行此操作的示例片段如下： </p> <div class=\"text-caption bg-muted q-pa-md\"> <div class=\"code code-grey\">// 导入 Umbra 类</div> <div class=\"code code\"> <span class=\"code-blue\">import </span> <span class=\"text-grey\">{</span> Umbra <span class=\"text-grey\">} </span> <span class=\"code-blue\">from</span> <span class=\"code-green\">'@umbra/umbra-js'</span>; </div> <br /> <div class=\"code code-grey\">// 用户连接他们的钱包后把`signer`设为ethers JsonRpcSigner</div> <div class=\"code code-grey\">// 下面的行将从用户那里要求签名，</div> <div class=\"code code-grey\">// 计算他们的消费和查看键，但是</div> <div class=\"code code-grey\">// 只将查看的 KeyPair 实例返回给调用者。</div> <div class=\"code code\"> <span class=\"code-blue\">const </span> <span class=\"text-grey\">{</span> viewingKeyPair <span class=\"text-grey\">}</span> = <span class=\"code-blue\">await</span> Umbra.<span class=\"code-pink\" >generatePrivateKeys</span >(signer); </div> </div>",
    "hooks": "什么是 Hooks 以及如何使用它们？",
    "hooks-answer": "如果您熟悉 {0} 或者其他类似的标准，你已经熟悉了钩子（Hooks）的概念。 除了被调用方法的核心逻辑之外，钩子还允许调用者执行其他操作。在 ERC-777 的情况下，在将代币转移到合同后，可以使用转移挂钩来调用合同上的方法。",
    "hooks-answer-rest": "<p> Umbra 的工作方式类似——当从合约中提取资金时——用户可能希望将它们直接存入一个 DeFi 协议，或者将他们的 DAI 换成 ETH。Hooks 可以让您做到这一点。 </p> <p>您会注意到 Umbra 合约公开了多种提款方法。首先我们有：</p> <ol> <li><span class=\"code\">withdrawToken()</span>用于标准提款，即简单转账</li> <li> <span class=\"code\">withdrawTokenOnBehalf()</span> 具有与 <span class=\"code\">withdrawToken()</span>相同的功能 ，但允许中继者代表您提交提款以支持元交易。</li> </ol> <p>然后我们有两个钩子方法：</p> <ol> <li> <span class=\"code\">withdrawTokenAndCall()</span> 类似于 <span class=\"code\">withdrawToken()</span>, but ，但允许你传入合约的地址和调用该合约的数据。</li> <li> <span class=\"code\">withdrawTokenAndCallOnBehalf()</span> 类似于 <span class=\"code\">withdrawTokenOnBehalf()</span>，但也允许您传入合约地址和调用该合约的数据。 </li> </ol> <p> 要使用钩子，首先需要编写和部署符合 <span class=\"code\">IUmbraHookReceiver</span> 接口的钩子合约。这需要合约实现一个调用 <span class=\"code\">tokensWithdrawn()</span> 的方法，该方法需要一些参数。此合约的地址将作为上述方法中  <span class=\"code\">_hook</span> 输入的值传递。",
    "hooks-answer-encode-data": " 然后你需要对钩子合约将接收并可以操作的调用数据进行编码。见 ethers.js 文档的 {0} 部分以获取有关如何编码函数数据的信息。</p> ",
    "hooks-answer-encoding-data": "编码数据",
    "hooks-answer-end": "<p> 这些就是您了解钩子所需的知识。有了钩子合约的地址和编码的调用数据，您就可以调用两个基于钩子的方法之一了。 </p>"
  },
  "AccountReceiveTable": {
    "processing-results": "正在处理结果...",
    "configure-umbra": "在注册 Umbra 之前，您将无法接收资金。",
    "navigate-to-setup": "请导航到{0}页面来注册",
    "setup": "注册",
    "keys-dont-match": "为此帐户发布的隐形密钥与其生成的密钥不匹配。请导航到 {0} 页并完成注册流程，以确保发布的密钥与此帐户匹配。不然可能会导致发送到您帐户的付款难以提取，甚至无法提取。 ",
    "learn-more": "了解更多",
    "scan-settings": "更改扫描设置",
    "account-empty": "此帐户尚未收到任何资金",
    "received-funds": "收到的资金",
    "sender": "发送者(Sender)",
    "stealth-receiver": "隐形接收者(Stealth Receiver)",
    "received": "已收到(Received)",
    "withdrawn": "已提取(Withdrawn)",
    "hide": "隐藏",
    "withdraw": "提取(Withdraw)",
    "receiver": "接受者",
    "scanning-complete": "扫描已成功完成",
    "custom-prv-key": "使用自定义私钥",
    "scanned-from-block": "从此块扫描",
    "to": "到",
    "all-blocks-scanned": "所有块都已扫描",
    "scanned-all-blocks-up-to": "扫描了所有块，直到",
    "to-current-block": "当前块",
    "private-key-copied": "私钥已复制到剪贴板",
    "date-received": "收到日期",
    "amount": "金额",
    "wallet-not-connected": "钱包未连接。尝试刷新页面并连接您的钱包",
    "address-copied": "地址已复制到剪贴板",
    "umbra-instance-not-found": "未找到Umbra实例：Umbra instance not found",
    "provider-not-found": "未找到提供程序：Provider not found",
    "no-announcement-selected": "未选择提款公告：No announcement is selected for withdraw",
    "signer-or-provider-not-found": "未找到签名者或提供程序：Signer or provider not found",
    "fee-not-set": "费用未设置：Fee is not set",
    "invalid-chain-id": "无效的链 ID：Invalid chainID",
    "receiver-tool-tip": "收到这些资金的隐形地址看起来像是一个空地址。它不能被追随到您的帐户，但只有您有能力生成其私钥。"
  },
  "AccountReceiveTableWarning": {
    "withdrawal-warning": "您正在提款到 {0} ，其中包含以下警告：",
    "withdrawal-warning-rest": "<span class=\"text-bold\">程序不建议您继续提款</span>，除非您知道自己在做什么。因为这可能会减少或完全删除 Umbra 提供的隐私属性。",
    "learn-more": "了解更多",
    "acknowledge-risks": "我承认此操作有风险"
  },
  "AccountReceiveTableWithdrawConfirmation": {
    "confirm": "确认",
    "cancel": "取消",
    "confirm-withdrawal": "确认提款",
    "to": "提取到",
    "amount": "金额",
    "tx-fee": "交易费",
    "relayer-gas-fee": "中继器Gas费",
    "you-will-receive": "您将收到",
    "cannot-withdraw": "无法提现，请更正费用错误：Cannot withdraw, please correct fee error",
    "withdraw-in-progress": "正在提款...",
    "view-transaction": "查看交易"
  },
  "Argent": {
    "warning": "警告：Argent兼容性问题： Warning: Argent Compatibility Issues",
    "warning-paragraph": "<p class=\"text-bold\"> Umbra 与 Argent 的标准安全模型不兼容。虽然您仍然可以将 Umbra 与 Argent 一起使用，但如果您切换设备或必须依靠社交恢复而不首先提取通过Umbra发送给您的任何资金，则您将面临损失资金的风险。 </p> <p> Umbra 的工作原理是从钱包的私钥派生出特定于应用程序的密钥。Argent的独特之处在于其安全性不依赖于您的私钥。这在很多方面都是好的。 </p> <p>但是，在使用 Umbra 时，必须注意以下事项：</p> <ol> <li> 如果您将Argent钱包恢复到新设备上，则新钱包将具有相同的地址，但具有不同的私钥。除非您有权访问旧设备，否则通过Umbra发送的您尚未提取的资金将无法恢复。 </li> <br /> <li> 因此，当您获得新设备时，您应该首先使用旧设备提取所有资金，然后重复Umbra帐户注册并重新发布密钥。很快，该应用程序将尝试检测何时需要执行此操作，以最大程度地减少资金损失的可能性，但现在您必须手动执行此操作。 </li> <br /> <li> 与其他应用程序不同，Umbra 接收的资金的安全性不受标准 Argent 安全模型的保护，而只是受您的私钥保护。 </li> </ol>",
    "acknowledge-risks": "我承认此操作有风险"
  },
  "ConnectWalletCard": {
    "connect-wallet": "连接钱包"
  },
  "WithdrawForm": {
    "withdraw-address": "输入提款地址",
    "address": "地址",
    "fetching-fee-estimate": "在接收费用估计...",
    "withdrawal-fee": "提款费：",
    "estimated-withdrawal-fee": "预计提款费用：",
    "withdraw-in-progress": "正在提款......",
    "warning": " <span class=\"text-bold\">警告</span>: 在输入提款地址之前，请确保您了解安全隐患。如果您提款到与您公开关联的地址，则此交易的隐私将丢失。",
    "learn-more": "了解更多",
    "hide": "隐藏",
    "show": "显示",
    "stealth-prv-key": "隐形地址私钥",
    "withdraw": "取款",
    "enter-valid-address": "请输入有效地址"
  },
  "Utils": {
    "Alerts": {
      "transaction-pending": "正在处理您的交易(Your transaction is pending)",
      "transaction-succeeded": "您的交易已成功(Your transaction has succeeded)",
      "transaction-failed": "您的交易已失败(Your transaction has failed)"
    },
    "Address": {
      "name-publicly-viewable": "此名称可公开查看",
      "name-resolves-to-ens": "此名称解析为可公开查看的 ENS 名称 ",
      "name-resolves-to-cns": "此名称解析为可公开查看的 CNS 名称 ",
      "it": "它",
      "resolves-to": "解析为",
      "is": "是",
      "is-erc20": "它是一个 ERC-20 代币",
      "is-erc721": "它是一个 ERC-721 令牌",
      "same-addr-as-wallet": "与连接的钱包地址相同",
      "same-addr-as-stealth": "与隐形地址相同",
      "address-it-resolves-to": "它解析为的地址",
      "has-poap-tokens": "具有 POAP 令牌"
    }
  },
  "connect": {
    "selectingWallet": {
      "header": "可用钱包",
      "sidebar": {
        "heading": "开始使用",
        "subheading": "连接您的钱包",
        "paragraph": "连接您的钱包就像'登录'Web3一样。 从选项中选择您的钱包，即可开始。"
      },
      "recommendedWalletsPart1": "{app} 只支持",
      "recommendedWalletsPart2": "在这个平台上。 请使用或安装一个支持的钱包来继续使用",
      "installWallet": "您没有安装任何 {app} 支持的钱包, 请使用支持的钱包",
      "agreement": {
        "agree": "我同意以下",
        "terms": "Terms & Conditions",
        "and": "and",
        "privacy": "Privacy Policy"
      }
    },
    "connectingWallet": {
      "header": "{connectionRejected, select, false {Connecting to {wallet}...} 其他 {Connection Rejected}}",
      "sidebar": {
        "subheading": "批准连接",
        "paragraph": "请批准钱包中的连接并授权来继续访问。"
      },
      "mainText": "正在连接...",
      "paragraph": "确保选择所有您想授予访问权的账户",
      "previousConnection": "{wallet} 已经有一个待处理的连接请求， 请打开 {wallet} 应用程序登录并连接。",
      "rejectedText": "连接被拒绝了!",
      "rejectedCTA": "点击这里重试",
      "primaryButton": "返回到钱包"
    },
    "connectedWallet": {
      "header": "连接成功",
      "sidebar": {
        "subheading": "连接成功!",
        "paragraph": "您的钱包现在已经连接到 {app}"
      },
      "mainText": "已连接"
    }
  },
  "modals": {
    "actionRequired": {
      "heading": "需要采取的行动在 {wallet}",
      "paragraph": "请切换您钱包中的活动账户。",
      "linkText": "了解更多。",
      "buttonText": "好的"
    },
    "switchChain": {
      "heading": "交换链",
      "paragraph1": "{app} 要求您将钱包切换到 {nextNetworkName} 网络上才能继续。",
      "paragraph2": "*有些钱包可能不支持改变网络。 如果您不能在您的钱包中改变网络，您可以考虑切换到另一个钱包。"
    },
    "confirmDisconnectAll": {
      "heading": "断开所有钱包的连接",
      "description": "你确定要断开所有钱包的连接吗？",
      "confirm": "确认",
      "cancel": "取消"
    }
  },
  "accountCenter": {
    "connectAnotherWallet": "连接另一个钱包",
    "disconnectAllWallets": "断开所有钱包的连接",
    "currentNetwork": "当前网络",
    "appInfo": "应用信息",
    "learnMore": "了解更多",
    "gettingStartedGuide": "入门手册",
    "smartContracts": "智能合约",
    "explore": "探索",
    "backToApp": "返回到 dapp",
    "poweredBy": "提供者是",
    "addAccount": "添加账户",
    "setPrimaryAccount": "设置主账户",
    "disconnectWallet": "断开钱包",
    "copyAddress": "复制钱包地址"
  },
  "notify": {
    "transaction": {
      "txRequest": "您的交易正在等待您的确认",
      "nsfFail": "您没有足够的资金进行这项交易",
      "txUnderpriced": "您的交易的gas费太低了，试试更高的gas费吧",
      "txRepeat": "这可能是一个重复的交易",
      "txAwaitingApproval": "您有一个先前的交易等待您去确认",
      "txConfirmReminder": "请确认您的交易以继续",
      "txSendFail": "您拒绝了该交易",
      "txSent": "您的交易已被发送到网络上",
      "txStallPending": "您的交易在发送前已经停滞，请再试一次",
      "txStuck": "您的交易由于nonce缺口而被卡住了",
      "txPool": "您的交易已经开始",
      "txStallConfirmed": "您的交易已经停滞，没有得到确认",
      "txSpeedUp": "您的交易已被加快",
      "txCancel": "您的交易正在被取消",
      "txFailed": "您的交易已经失败",
      "txConfirmed": "您的交易已经成功",
      "txError": "哎呀，出错了，请再试一次",
      "txReplaceError": "更换您的交易出现错误，请重试。"
    },
    "watched": {
      "txPool": "您的账户 {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      "txSpeedUp": "交易 {formattedValue} {asset} {preposition} {counterpartyShortened} 已经被加快",
      "txCancel": "交易 {formattedValue} {asset} {preposition} {counterpartyShortened} 已被取消",
      "txConfirmed": "您的账户已成功 {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      "txFailed": "您的账户未能 {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      "txStuck": "您的交易由于nonce缺口而被卡住了"
    },
    "time": {
      "minutes": "分钟",
      "seconds": "秒钟"
    }
  }
}
