{
  "Home": {
    "header": "Send Stealth Payments",
    "description": "Only the sender and recipient know who received funds",
    "Tutorial": {
      "tutorial": "Tutorial",
      "receiving-funds": "Receiving Funds",
      "receive-first": "Use the <span class=\"text-bold\">Setup</span> page to configure your account",
      "receive-second": "Ask someone to send funds to your address, ENS, or CNS name through the Umbra app",
      "receive-third": "Check the <span class=\"text-bold\">Receive</span> page to withdraw funds",
      "sending-funds": "Sending Funds",
      "send-first": "Get the address, ENS, or CNS name of the person you're sending funds to",
      "send-second": "Complete the form on the <span class=\"text-bold\">Send</span> page"
    }
  },
  "Home-action-card": {
    "send": "Send",
    "send-description": "Send funds to another user",
    "receive": "Receive",
    "receive-description": "View and withdraw received funds",
    "setup": "Setup",
    "setup-description": "Setup your account to receive funds"
  },
  "Header-Links": {
    "home": "Home",
    "FAQ": "FAQ",
    "contact": "Contact"
  },
  "Base-Layout": {
    "settings": "Settings",
    "dark-mode": "Dark mode",
    "advanced-mode": "Advanced mode",
    "advanced-mode-description": "Enables advanced features such as private key export, additional recipient ID options, and event scanning settings.",
    "caution": "Use with caution!",
    "on": "on",
    "off": "off",
    "about": "About",
    "built-by": "Built by {0}",
    "links": "Links"
  },
  "Address-Settings": {
    "advanced-mode-on": "Advanced mode is on"
  },
  "Contact": {
    "contact": "Contact",
    "paragraph": "Read the {0} and still have questions? Feel free to get in touch! You'll likely get the fastest response on Discord.",
    "faq": "FAQ",
    "discord": "{0} on Discord",
    "join-us": "Join us",
    "twitter": "{0} Umbra on Twitter",
    "follow": "Follow",
    "email": "Email us at {0}"
  },
  "Send": {
    "sending-disabled": "Sending via Umbra has been temporarily disabled while we perform system maintenance. Please check back soon!",
    "send": "Send",
    "connect-your-wallet": "Connect your wallet to send funds",
    "connect-wallet": "Connect Wallet",
    "recipient": "Recipient's ENS name or address",
    "recipient-pkey": "Send using recipient's standard public key",
    "question-circle": "When checked, the public key used will be the standard public for the provided Ethereum address. The receiver will have to enter their account's private key into this app to withdrawal the funds.",
    "question-circle-warning": "Don't use this feature unless you know what you're doing.",
    "learn-more": "Learn more",
    "select-token": "Select token to send",
    "token": "Token",
    "amount": "Amount to send",
    "summary": "Summary",
    "sending": "Sending",
    "fee": "Umbra Fee",
    "fee-explain": "Transactions on %{chainName} are very cheap, so a small fee is charged to deter spamming the protocol.",
    "total": "Total",
    "max": "Max",
    "copy-payment-link": "Copy payment link",
    "enter-an-amount": "Please enter an amount",
    "enter-a-recipient": "Please enter a recipient",
    "select-a-token": "Please select a token",
    "send-at-least": "Please send at least",
    "amount-exceeds-balance": "Amount exceeds wallet balance",
    "please-complete-form": "Please complete the form",
    "wallet-not-connected": "Wallet not connected",
    "umbra-fee-exceeds-balance": "required for Umbra fee exceeds wallet balance"
  },
  "Receive": {
    "receive": "Receive",
    "connect-your-wallet": "Connect your wallet to scan for received funds",
    "connect-wallet": "Connect Wallet",
    "need-signature": "This app needs your signature to scan for funds you've received",
    "scan-funds": "Click below to scan for funds you've received",
    "sign": "Sign",
    "scan": "Scan",
    "scan-settings": "Scan Settings",
    "start-end": "Enter the start or end blocks to use when scanning for events. A blank start block will scan from block zero, and a blank end block will scan through the current block.",
    "start-block": "Start block",
    "end-block": "End block",
    "enter-prv-key": "Enter the private key to use when scanning for events. A blank private key will use the ones generated from your signature.",
    "prv-key": "Private key",
    "fetching": "Fetching announcements...",
    "scanning": "Scanning for funds...",
    "wait": "This may take a couple of minutes depending on your connection and device. This is normal&mdash; please be patient."
  },
  "Setup": {
    "setup": "Setup",
    "connect-wallet": "Connect your wallet to setup your account",
    "generate-stealth": "Generate and Publish Stealth Keys",
    "paragraph": " Use the button below to complete the setup process. This will result in two prompts from your wallet: <ol> <li> <span class=\"text-bold\">Sign a message</span> used to generate your Umbra-specific pair of private keys. These keys allow you to securely use Umbra without compromising the private keys of your connected wallet. You do not need to save these keys anywhere! </li> <li> <span class=\"text-bold\">Submit a transaction</span> to save the corresponding public keys on-chain, so anyone can use them to send you stealth payments. </li> </ol>",
    "setup-account": "Setup account",
    "complete": "Setup Complete!",
    "return-to-home": "You may now return {0} to send or receive funds",
    "return-home": "home"
  },
  "Error": {
    "error": "Oops. Nothing here..."
  },
  "FAQ": {
    "faq": "Frequently Asked Questions",
    "intro": "Introduction",
    "what-is-umbra": "What is Umbra?",
    "what-is-umbra-answer": "<p>Umbra is a stealth address protocol for Ethereum. That means it allows a payer to send funds to a fresh address. That address is controlled by the intended receiver, but only the payer and the receiver know that. </p><p> One way to think of Umbra is this: Imagine if, before anyone sent you funds, you sent them a brand new,never before used address. Only the sender would know you control that address, which adds a layer of privacy to your payment. Payments via Umbra work similarly, but are non-interactive—you don’t need to give someone a fresh address, they can just generate one they know only you will be able to access.</p>",
    "an-example": "Can you walk me through an example?",
    "an-exmaple-answer": "<p>Alice owns a business and hires Bob to subcontract for her. She agrees to pay Bob 1,000 Dai/week for his work. Bob owns the ENS address <span class=\"code\">bob.eth</span>. If Alice sent the funds each week to <span class=\"code\">bob.eth</span>, anyone looking at the chain could trivially know that Alice is paying Bob 1,000 Dai each week.</p><p>Instead, Bob and Alice will use Umbra for private payments. The first time Bob visits the Umbra app, he sets up his account, enabling anyone to privately pay him using his address. Alice then uses Umbra to send 1,000 Dai to Bob each week— she only needs to know his address or ENS name.</p><p>On chain, we see Alice pays 1,000 Dai to a new empty address each week. Behind the scenes, Bob controls the keys to each of these addresses via Umbra, but nobody except Alice and Bob knows this.</p><p>Bob uses Umbra to withdraw his 1,000 Dai each week. He only needs to provide an address to send it to. It’s best for him to use an address that’s not tied to his identity. He usually chooses to send it straight to an exchange, where he sells it for fiat as needed. Importantly, this means <strong>Bob's exchange now knows this payment went to him</strong>. To the casual chain observer— one without access to proprietary centralized exchange data— the fact that Alice's payment went to Bob is obscured.</p><p> Consider another example: Liza runs a website that asks for donations. If everyone donated by directly sending her funds, everyone would know how much Liza received in donations. If donations were sent with Umbra instead, each donation would be sent to a different address, and only Liza would know the total amount of donations she received.</p>",
    "wen-token": "Does Umbra have a token?",
    "wen-token-answer": "No.",
    "how-does-it-work": "How does it work?",
    "how-does-it-work-answer": "<p>Below is a high level description of how Umbra works:</p><ol><li>When setting up your Umbra account, users sign a message. The hash of this message is used to generate two private keys—a \"spending key\" and a \"viewing key\". </li> <li>The corresponding public keys are both published on-chain as records associated with your address.</li><li>A payer uses your address or ENS name to look up your two public keys. Separately, the payer generates a random number.</li><li>The random number is used with the spending public key to generate a \"stealth address\" to send funds to. The same random number is used with the viewing public key to encrypt the random number.</li><li> Using the Umbra contract, the payer sends funds to the stealth address and the encrypted data is emitted as an <span class=\"code\">Announcement</span> event.</li><li>The receiver scans all <span class=\"code\">Announcement</span> events from the Umbra contract. For each, they use their viewing private key to decrypt the random number, then multiply that number by their spending private key to generate the stealth private key. If the stealth private key controls the address funds were sent to, this payment was for the receiver </li> <li> The receiver can now use the private key to either directly send the transaction required to withdraw funds to another address, or sign a meta-transaction to have the withdrawal request processed by a relayer.</li></ol>",
    "how-does-it-work-see-the": "See the {0} section for more details.",
    "how-does-it-work-technical-dtails": "Technical Details: How does it work?",
    "how-private": "How private is Umbra?",
    "how-private-answer": "<p>Umbra offers a limited set of privacy guarantees and it’s important to understand them before using the protocol. Umbra does <span class=\"text-bold\">not</span> offer \"full\" privacy like Aztec or Zcash. It simply makes it impossible for any outside observers (i.e. anyone who is not the sender or the receiver) to know who the sender paid by looking at the receiving address.</p><p>It’s important to understand that poor hygiene by the receiver— for example, sending the funds directly to a publicly known address— eliminates the privacy benefits for both the sender and receiver.</p><p>The privacy properties of Umbra can also be diminished if an observer can narrow down the set of potential recipients for a given a transaction. Any valid public key can be used as a recipient, and anyone who has sent a transaction on Ethereum has a publicly available public key. Therefore, by default, the \"anonymity set\"—the set of potential recipients of a transaction—is anyone who has ever sent an Ethereum transaction!</p><p>In practice this isn’t necessarily the case, and an observer may be able to narrow down the list of recipients in a few ways:</p><ol><li>Most users will use the Umbra stealth key registry to send funds, so the recipient most likely has keys published there.</li><li>Poor hygiene when withdrawing funds from your stealth addresses can reduce or entirely remove the privacy properties provided by Umbra. See the \"What address are safe for withdrawing funds to?\" for more details. Always use caution when withdrawing!</li></ol>",
    "umbra-vs-mixer": "Is Umbra a mixer?",
    "umbra-vs-mixer-answer": "<p> No. Umbra is not a mixer and does not use zero knowledge proofs. Instead, Umbra is based on ordinary elliptic curve cryptography. It’s meant for payments between two entities, and comes with a different set of privacy tradeoffs. Rather than breaking the link between sending and receiving address, like a mixer, Umbra makes that link meaningless. Everyone can see who sent the funds, and everyone can see the address funds were sent to, but that receiving address has never been seen on-chain so it’s impossible for any outside observers to know who controls it. </p>",
    "account-setup": "Account Setup",
    "what-is-setup": "What is account setup?",
    "what-is-setup-answer": " <p> A User signs a message, and from that Umbra public keys and private keys are generated. A transaction is made on the Umbra stealth key registry, associating the public keys with your address. </p>",
    "is-setup-required": "Is account setup required?",
    "is-setup-required-answer": " <p> This step is not technically required, but is strongly recommended for security reasons. In order to access stealth funds, the Umbra app needs your private keys. Inputting your wallet’s private keys into any website is very dangerous, and we don’t want you do to that! By going through the account setup process, you sign a message to generate an app-specific set of Umbra private keys. This is much more secure, as Umbra never has your wallet’s private key. </p>",
    "why-setup-again": "Why do I need to setup my account again?",
    "why-setup-again-answer": "<p> If you configured your Umbra account while the service was still in Beta&mdash;before October 2021&mdash;you need to redo setup. This requires one signature and one transaction. </p> <p> This additional setup step is due to an upgrade to Umbra's stealth key registry system. The old system relied on records placed on the ENS resolver associated with a user's address. The new system is much simpler, and uses a simple mapping between the user's address and their stealth keys. </p> <p> The new system was developed in response to user feedback during Umbra's Beta period. The old system required multiple transactions, and also required senders to use the receiver's ENS name, which caused confusion. The new system requires only a single transaction, and senders can provide either the receiver's ENS name or their regular Ethereum address. Overall, the new system is simpler to both configure and use. </p>",
    "why-setup-again-answer-issue": "For an even more in depth and technical explanation of this upgrade, see {0} on Umbra's Github repository.",
    "why-setup-again-answer-this-issue": "this issue",
    "sending-funds": "Sending Funds",
    "why-only-tokens": "Why are only certain tokens available?",
    "why-only-tokens-answer": "<p> When you send ETH, the ETH is sent directly to the computed stealth address. That stealth address now has ETH, which is required to pay gas, so the receiver can easily transfer that ETH with an ordinary send. </p> <p> When you send tokens, the tokens are not sent directly to the computed stealth address. If they were, you’d first need to get ETH into the stealth address in order to pay for the gas to withdraw funds (or use some costly CREATE2 schemes). Instead, the tokens are held by the contract and can be released in one of two ways: </p> <ol> <li>The stealth address directly calls the <span class=\"code\">withdrawToken()</span> method</li> <li> Anyone calls <span class=\"code\">withdrawTokenOnBehalf()</span> and passes in a signature from the stealth address. This enables meta-transactions to be used with the relayer of your choice. </li> </ol> <p> By default, the Umbra app uses a relayer from the Umbra team. Managing relayers and making sure you are properly reimbursed for gas fees can be tricky, so to start only a few tokens are enabled and the list of supported tokens will be expanded. </p>",
    "when-receive": "When will the recipient receive their funds?",
    "when-receive-answer": "<p> Immediately! The recipient receives and can withdraw funds immediately after the send transaction is mined. </p>",
    "min-amount": "Why is there a minimum send amount?",
    "min-amount-answer": " <p> When you send funds with Umbra, the recipient address is an address that has never been used before. This means it has no ETH and no tokens, so it must pay for withdrawals using the funds that were sent to it. When sending ETH, this is done with a regular transfer. When sending tokens, this is done with a relayer so fees can be paid with the received tokens. Therefore, there is a minimum send amount to ensure the recipient can always withdraw their funds easily. </p>",
    "umbra-fee": "Why is there sometimes an Umbra fee?",
    "umbra-fee-answer": "<p> Finding funds you've received through Umbra requires scanning through all sent transactions, then checking each to find which ones are for you. </p> <p> On networks with very cheap transaction fees, the Umbra contract charges a small <span class=\"code\">toll</span> when sending funds to deter spam transactions, as spam would make it more difficult to scan through all sent transactions. </p>",
    "payment-links": "What are the payment links?",
    "payment-links-answer": " <p> When on the Send page, fill out some or all of the Send form and click the <span class=\"text-italic\">Copy payment link</span> button. This will copy a URL to your clipboard that, when visited, pre-populates the send form with the values in the URL. </p> <p> Be careful when specifying an amount as part of your payment link, as it can reduce privacy. For example, if you share a payment link so people can donate 100 DAI to you, and suddenly lots of 100 DAI sends start going through Umbra, observers will know that it's very likely those transfers are to you. </p>",
    "receiving-funds": "Receiving Funds",
    "safe-address": "What addresses are safe for withdrawing funds to?",
    "safe-address-answer": "<p> We suggest 3 ways of withdrawing in a privacy-preserving way. Note that each comes with its own set of tradeoffs. </p> <ol> <li> Withdraw to an address that is not publicly associated with your identity (tradeoff: the sender will now be able to infer you control that address) </li> <li> Generate a new address and withdraw into that (tradeoff: if you’ve received tokens, you’ll have to fund that address with ETH for gas before you can use them) </li> <li> Withdraw to an exchange address (tradeoff: if you withdraw to Coinbase, then Coinbase will know who sent you funds) </li> </ol>",
    "non-safe-address": "What addresses are NOT safe for withdrawing funds to?",
    "non-safe-address-answer": "<p> The risk to consider when withdrawing is that if you withdraw to an address that is associated with some publicly known identity, then privacy is lost as follows: </p> <p> Let’s say Alice sends funds to Bob via Umbra. Right now, only Alice and Bob know that Alice paid Bob. Any other observers know Alice sent funds to someone, but they don’t know who that someone is. </p> <p> If Bob withdraws those funds to his publicly known <span class=\"code\">bob.eth</span> address, which resolves to <span class=\"code\">0x123...def</span>, then observers know one of two things happened: </p> <ol> <li>Scenario 1: Alice sent funds to Bob, then Bob withdrew them to his own address, OR</li> <li>Scenario 2: Alice sent funds to someone that knows Bob, and paid Bob from their stealth address</li> </ol> <p> Additionally, consider the case where Bob withdraws by directly paying his friend Charlie—Charlie now knows that Alice paid Bob. </p> <p> To help mitigate this, the Umbra app will try to warn you if you enter a withdrawal address that might reduce your privacy. Therefore you’ll see warnings if the app detects you are withdrawing to an address that: </p> <ol> <li>Has an ENS or CNS name</li> <li>Owns POAP tokens</li> <li>Is the wallet you are logged in with</li> <li>(Coming soon): Withdrawing to an address that has contributed to Gitcoin.</li> </ol> <p> This is <span class=\"text-bold\">not</span> a comprehensive list of potentially dangerous withdrawal addresses, so use caution. </p>",
    "umbra-withdrawal": "Can Umbra make it easier to withdraw funds in a privacy preserving way?",
    "umbra-withdrawal-answer": "<p> Yes! This is an area where we intend to make many improvements in the future, mostly by relying on Umbra’s post-withdrawal hook functionality. </p> <p>Some examples of how we plan to leverage this include:</p> <ol><li>Atomically swap some tokens to ETH and send all of it to a fresh address</li> <li>Withdraw funds straight into DeFi protocols</li> </ol> <p> There are many other options which we can pursue via hooks to greatly expand the privacy preserving withdrawal options. </p>",
    "scan-time": "Why does it take so long to scan for my funds?",
    "scan-time-answer": "<p> To find payments sent to you, the app needs to search through every payment that was sent and check if it was for you. So the more payments that have been sent, the longer this will take. </p>",
    "scan-time-answer-issue": "This is an open research problem with various potential solutions ({one}{two}), and we hope to improve this over time.",
    "when-withdrawal": "When are my funds available to withdraw?",
    "when-withdrawal-answer": "<p>Immediately! You recieive and can withdraw funds immediately after the send transaction is mined.</p>",
    "security": "Security",
    "audit": "Has Umbra been audited?",
    "audit-answer-contract": "The {contracts} have been audited by ConsenSys Diligence, and the audit report can be found {here}.",
    "audit-contracts": "contracts",
    "audit-here": "here",
    "audit-answer-umrba-js": "The {umbra-js} {library} responsible for handling the required off-chain logic and elliptic curve operations—has been audited by Least Authority, and the audit report can be found {here}.",
    "audit-library": "library",
    "audit-answer-umbra-off-chain": "Off-chain elliptic curve operations are a core part of Umbra’s business logic, so we rely on {PaulMillers}'s simple, zero-dependency {noble-secp256k1} library to handle this. Thanks to the {community}, we were able to raise enough funds to pay for an audit of this library with Cure53. You can read the audit report {here}.",
    "audit-community": "community",
    "umbra-risk": "What are the risks of Umbra?",
    "umbra-risk-answer": "<p> Like all software in the crypto ecosystem, using Umbra comes with risks. This includes risks of critical bugs, hacks, or other attacks from malicious actors. Any or all of these scenarios could result in a loss of funds. </p> <p>To be more specific, here are a few of the risks we’ve seen play out with other projects in the past:</p> <ol> <li>Contract vulnerabilities that allow attackers to steal contract funds or leaves them stuck</li> <li>A bug in our off-chain code that causes funds to be sent to an unrecoverable address</li> <li>DNS being hijacked to steal user’s private keys</li> <li>Supply chain attacks of frontend code to steal user’s private keys</li> </ol> <p> It goes without saying that we’re working hard to prevent these, but that does not mean we’ll succeed. Umbra is provided with absolutely no warranty, and you should use it at your own risk. </p>",
    "crypto-js": "Is cryptography in JavaScript secure?",
    "crypto-js-answer": "In general, a JavaScript execution environment is not ideal for meeting security requirements. It presents challenges in hiding secret data in memory (e.g. your app-specific private keys) and preventing that data from being written to disk. Using JavaScript also means the underlying cryptography library may be susceptible to things like {timing-attacks}. Umbra uses {noble-secp256k1} for all cryptography, and you can read more about its limitations and mitigation to such vulnerabilities {here}.",
    "crypto-js-timing-attacks": "timing attacks",
    "crypto-js-here": "here",
    "crypto-js-answer-rest": "<p> However, the Ethereum ecosystem consists of many wallets and applications that rely on JavaScript cryptography and so far there have been no major issues as a result of this, so this approach is likely a suitable trade-off for most users. </p>",
    "tech-details": "Technical details",
    "network-addrs": "What networks is Umbra deployed on and what are the contract addresses?",
    "network-addrs-core": "The core {umbra} contract is deployed at {umbra-addr} on {mainnet}, {rinkeby}, {optimism}, {polygon}, and {arbitrum}",
    "network-addrs-registry": "The {stealthRegistry} is deployed at {stealthRegistryAddr} on {mainnet}, {rinkeby}, {optimism}, {polygon}, and {arbitrum}",
    "how-it-works": "How does it work?",
    "how-it-works-answer": "<p class=\"text-bold\">Stealth Address Overview</p> <p>Let’s start with how the Umbra protocol (and more generally, how stealth addresses) work:</p> <p> The recipient has public key <span class=\"code\">P</span> and private key <span class=\"code\">p</span>. The sender generates a random number <span class=\"code\">r</span>, and computes a stealth public key as <span class=\"code\">P_stealth = P * r</span> using elliptic curve multiplication. The sender derives the Ethereum address <span class=\"code\">a_stealth</span> from that public key, and sends funds to it. Thanks to the magic of elliptic curve math, the recipient can generate the private key <span class=\"code\">p_stealth</span> needed to access funds at <span class=\"code\">a_stealth</span> by computing <span class=\"code\">p_stealth = p * r</span>. </p> <p> The first problem to solve is how does the sender get the value <span class=\"code\">r</span> to the receiver? If <span class=\"code\">r</span> was publicly known, observers could determine who funds were sent to by computing <span class=\"code\">P * r</span> for various published <span class=\"code\">P</span> values until the find the stealth address. So <span class=\"code\">r</span> needs to be encrypted. </p>",
    "how-it-works-answer-ECDH": "Encryption is done with {ECDH} (ECDH), meaning the sender uses the recipient’s public key to encrypt the random number. The encrypted random number gives us the cipertext {c}. The encrypted random number {c} and stealth address {a-stealth} are emitted as an {announcement} event from the Umbra contract. ECDH requires the sender to generate an ephemeral private key for encryption, so the ephemeral public key {P-ephemeral} that the receiver will need to decrypt is also emitted in this event.",
    "how-it-works-answer-part-2": "<p> Now the receiver can scan through all <span class=\"code\">Announcement</span> events and find their funds as follows: </p> <ul> <li> Using their private key <span class=\"code\">p</span> with <span class=\"code\">P_ephemeral</span>, they can compute the ECDH shared secret and decrypt the random number. This will always decrypt to <span class=\"text-italic\">something</span>, but we don’t yet know if it decrypted to the correct number. </li> <li> So the recipient multiplies the decrypted random number by <span class=\"code\">p</span> to get <span class=\"code\">p_stealth</span>, and computes the address controlled by <span class=\"code\">p_stealth</span> </li> <li> If the address controlled by <span class=\"code\">p_stealth</span> matches the <span class=\"code\">a_stealth</span> stealth address included in the <span class=\"code\">Annoucement</span>, the recipient knows that payment was for them and can withdraw it using <span class=\"code\">p_stealth</span>. </li> </ul> <p class=\"text-bold\">Application Private Key</p> <p> As seen from the above explanation, the app will need access to your private key to perform the required math. But when you connect your wallet to an app, the wallet does not share your private key with the app. This is good, because if it did any app you use could steal your funds! So how does Umbra access your key? There’s a few options: </p> <ol> <li> Ask the user to input their wallet’s private key into a form. This is terrible from both a security and user-experience perspective, so we do not do this </li> <li> Generate a random private key and ask you to back it up. This works, but having to backup an app-specific secret is not ideal. </li> <li>Ask the user to sign a message, hash the signature, and generate the key from the signature.</li> </ol>",
    "how-it-works-answer-option-3": "Option 3 solves the issues of otpions 1 and 2, and is the approach used by the app. Similar approaches are used by {loopring} and {zksync} as well, and they were the inspiration for this approach.",
    "how-it-works-answer-end": "<p class=\"text-bold\">Scanning for Funds</p> <p> The final consideration has to do with scanning. Because every single <span class=\"code\">Announcement</span> needs to be scanned, it can take a long time to find your finds. </p> <p> One way to speed this up (from the user's perspective) is to delegate scanning to a third-party service and have them notify you when you receive funds. But the scanning service needs your private key <span class=\"code\">p</span> to determine if you received funds, and if they have <span class=\"code\">p</span> they can steal your funds! </p> <p> We can solve this by instead generating two application-specific private keys. One private key will be the viewing private key, <span class=\"code\">p_view</span>, used for encrypting the random number. The other will be the spending private key, <span class=\"code\">p_spend</span>, used for computing the stealth address and accessing those funds. Therefore, our send and receive flow is now modified a bit to: </p> <ol> <li> Recipient has two private keys, <span class=\"code\">p_spend</span> and <span class=\"code\">p_view</span>, and publishes the corresponding public keys <span class=\"code\">P_spend</span> and <span class=\"code\">P_view</span>. </li> <li> The sender generates a random number <span class=\"code\">r</span> and encrypts it using <span class=\"code\">P_view</span> and an ephemeral private key <span class=\"code\">p_ephemeral</span> to generate a ciphertext <span class=\"code\">c</span> </li> <li> The sender computes the stealth address as the address derived from <span class=\"code\">P_stealth = P_spend * r</span> and sends funds to that address </li> <li> The Umbra contract emits <span class=\"code\">c</span>, <span class=\"code\">P_ephemeral</span>, and stealth address <span class=\"code\">a_stealth</span> </li> <li> For each event, the receiver uses <span class=\"code\">p_view</span> and <span class=\"code\">P_ephemeral</span> to decrypt <span class=\"code\">r</span>, then checks if <span class=\"code\">p_stealth = p_spend * r</span> is the private key that controls a_stealth </li> </ol> <p> With this approach, the recipient can provide a third-party scanning service with <span class=\"code\">p_view</span> and <span class=\"code\">P_spend</span>. The service can now check if the recipient has received funds without having the ability to spend them. </p>",
    "spend-view-keys": "What are spending and viewing keys?",
    "spend-view-keys-answer-1": "Borrowing the {0} from Zcash, Umbra allows, but does not require, users to use different private keys for the \"encrypt random number\" and \"compute stealth address\" steps. This is the default behavior of the Umbra app, but it can be overriden by using Advanced Mode.",
    "nomenclature": "nomenclature",
    "spend-view-keys-answer-2": "See {0} for more details on how spending and viewing keys work.",
    "spend-view-keys-technical-details": "\"Technical Details: How does it work?\"",
    "advanced-mode": "Advanced Mode",
    "what-is-advanced": "What is Advanced Mode?",
    "what-is-advanced-answer": "<p> For power users who understand the protocol, how it works, and the risks involved, you may want to enable Advanced Mode. This provides a range of additional capabilities, but improper use can result in privacy being reduced or funds being lost. Use with caution! </p>",
    "send-to-pkey": "How do I send funds to a user by their address or public key?",
    "send-to-pkey-answer": "<p> As long as a user has sent at least one transaction on Ethereum, you can send funds to a stealth address they control even if they have not setup their address for use with Umbra. This works as follows: </p> <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Send page and connect your wallet</li> <li>Check the box that says \"Send using recipient's standard public key\"</li> <li> The recipient field normally only accepts addresses in the stealth key registry, and uses the public keys published there to generate stealth address. But now, it will allow you to put in any address, and use the standard public key that underlies that address. It will also accept a public key, an address, or even a transaction hash! (Using a transaction hash is effectively the same as entering the <span class=\"code\">from</span> address of that transaction) </li> <li>Continue to send funds like normal</li> </ol> <p>Be aware of the following tradeoffs incurred when sending funds this way:</p> <ol> <li>This transaction does not use separate spending and viewing keys, and the same key is used for each</li> <li> To withdraw funds from the app, the recipient must enable Advanced Mode and manually paste their private key into the website. This is the big tradeoff, so make sure the recipient is ok with this before sending funds this way. </li> </ol>",
    "access-funds": "How can I access funds sent to me by using my address as the recipient identifier?",
    "access-funds-answer": "<p> If funds were sent to you by using your public key directly, your address, or a transaction hash of a transaction you sent, your funds can still be accessed. </p> <p>The most secure way to do this is locally using the <span class=\"code\">umbra-js</span> package:</p> <ol> <li>Setup a local JavaScript project with <span class=\"code\">yarn init</span></li> <li>Install ethers.js and umbra-js using <span class=\"code\">yarn add ethers @umbra/umbra-js</span></li> <li> In your script, perform the following: <ol> <li>Connect to a mainnet provider with ethers</li> <li> Initialize an instance of the Umbra class with <span class=\"code\">const umbra = new Umbra(provider, 1)</span> </li> <li> Initialize an instance of the KeyPair class with your address’ private key, <span class=\"code\">const keyPair = new KeyPair(myPrivateKey)</span> </li> <li> Use the <span class=\"code\">umbra.scan()</span> method to search for your funds. The <span class=\"code\">viewingPrivateKey</span> input is now be given by <span class=\"code\">keyPair.privateKeyHex</span>, and the <span class=\"code\">spendingPublicKey</span> input is given by <span class=\"code\">keyPair.publicKeyHex</span> </li> <li> For each <span class=\"code\">Announcement</span>, you can use the static method <span class=\"code\" >Umbra.computeStealthPrivateKey(keyPair.privateKeyHex, announcement.randomNumber)</span > to compute the stealth private key </li> </ol> </li> <li> Now that you have the stealth private key(s), you can sign and relay withdrawal transactions using any method you prefer. See the various withdrawal methods in the Umbra class that may be helpful here. </li> </ol> <p> If you prefer convenience over security, you can instead withdraw using the Umbra app, but be careful—entering your private key into a website is never a good idea! If you do want to go this route: </p> <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Receive page and connect your wallet</li> <li>Before scanning, enter the appropriate private key in the form</li> <li>Leave the start block and end block fields blank if you don’t need them</li> <li>Click \"Scan\" to scan for funds</li> </ol>",
    "scan-range": "How can I scan just certain range of blocks?",
    "scan-range-answer": "<p> If you have an idea of approximately when you were sent funds, you can speed up the scanning process of only querying events within a certain range of blocks. To do this: </p> <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Receive page and connect your wallet</li> <li>Before scanning, enter the desired start and end block numbers</li> <li>Leave the private key field blank if you don’t need it</li> <li>Click \"Scan\" to scan for funds</li> </ol> <p> The start and end block numbers will be saved in local storage and automatically applied next time you scan with advanced mode on. Leave both fields blank to clear the values and use the defaults. </p>",
    "view-prvkey": "How can I view the stealth private keys?",
    "view-prvkey-answer": "If you want to see the stealth private key for a certain payment you received: <ol> <li>Enable Advanced Mode</li> <li>Navigate to the Receive page and scan for funds</li> <li>For transactions that have not been withdrawn, click \"Withdraw\" to expand the row</li> <li> You’ll see text that says \"Show withdrawal private key\", which will show the stealth private key needed to withdraw this payment </li> </ol>",
    "for-developers": "For Developers",
    "build-on-umbra": "How can I build on top of Umbra?",
    "build-on-umbra-answer": "<p> Developer documentation is not yet written, but all code is thoroughly commented so it should be straightforward to read the code to understand how things work and build on top of it. </p> <p> The umbra-js library is a good starting point, as it will give you the full, big picture view of how Umbra works, as well as go into the details. Afterwards, you can check out the contract and to understand exactly where it fits in. </p> <p> The below should be a good order for traversing the umbra-js codebase. If you find this confusing, please let us know what a better order would be! </p> <ol> <li> <span class=\"code\">src/classes/Umbra.ts</span>: The <span class=\"code\">Umbra</span> class is a high-level class intended for developers to directly interact with. It abstracts away the complexity of the protocol into a few main methods: <ol> <li> <span class=\"code\">send()</span> is used to send funds to another user, and automatically handles the underlying cryptography required </li> <li> <span class=\"code\">generatePrivateKeys()</span> prompts the user for a signature and generates their spending and viewing keys. <span class=\"text-italic\"> Note: make sure the wallet being used supports deterministic ECDSA signatures with <a class=\"hyperlink\" href=%{link} target=\"_blank\">RFC 6979</a>. </span> </li> <li> <span class=\"code\">scan()</span> lets you find funds sent to the specified user, by providing just the user’s spending public key and viewing private key </li> <li> <span class=\"code\">withdraw()</span> lets a stealth address directly withdraw both tokens and ETH </li> <li> <span class=\"code\">withdrawOnBehalf()</span> uses meta-transactions to relay a withdraw transaction on behalf of another user, and the <span class=\"code\">signWithdraw()</span> method is used to get the required signature </li> <li> <span class=\"code\">relayWithdrawOnBehalf()</span> can be used to relay a meta-transaction using the default Umbra relayer </li> </ol> </li> <li> <span class=\"code\">src/classes/KeyPair.ts</span>: This class is where the core cryptography logic lives. A <span class=\"code\">KeyPair</span> class is instantiated with either a private or public key, and the class methods help you perform various operations with those keys, including encryption/decryption, multiplication, and compression/decompression of public keys </li> <li> <span class=\"code\">src/classes/RandomNumber.ts</span>: This simple class is used to generate our 32 byte random number. </li> <li> <span class=\"code\">src/utils/utils.ts</span> contains various helper methods for a range of tasks, primarily related to getting a recipient’s public keys </li> <li> <span class=\"code\">src/types.ts</span>: You’ll see a few custom types used throughout, which are all defined here </li> </ol> <p> After reading through the above, you should be well-equipped to understand the Umbra.sol contract, which you’ll notice is actually quite simple. The one new part in the contract which you won’t have seen anything about yet is the hooks. You can read more about this in the \"What are Hooks and how do I use them?\" section. </p>",
    "receive-vkey": "How can I receive a user’s viewing key, but not their spending key?",
    "receive-vkey-answer": "<p> Currently, the only way to do this is request a user’s signature using <span class=\"code\">Umbra.generatePrivateKeys()</span>, which will return both their spending key and their viewing key. It’s up to you to discard the spending key and not use it. A sample snippet to do this is below: </p> <div class=\"text-caption bg-muted q-pa-md\"> <div class=\"code code-grey\">// Import the Umbra class</div> <div class=\"code code\"> <span class=\"code-blue\">import </span> <span class=\"text-grey\">{</span> Umbra <span class=\"text-grey\">} </span> <span class=\"code-blue\">from</span> <span class=\"code-green\">'@umbra/umbra-js'</span>; </div> <br /> <div class=\"code code-grey\">// Let `signer` be an ethers JsonRpcSigner generated when the user</div> <div class=\"code code-grey\">// connected their wallet. The below line will request a signature</div> <div class=\"code code-grey\">// from the user, compute both their spending and viewing keys, but</div> <div class=\"code code-grey\">// only return the viewing KeyPair instance to the caller.</div> <div class=\"code code\"> <span class=\"code-blue\">const </span> <span class=\"text-grey\">{</span> viewingKeyPair <span class=\"text-grey\">}</span> = <span class=\"code-blue\">await</span> Umbra.<span class=\"code-pink\" >generatePrivateKeys</span >(signer); </div> </div>",
    "hooks": "What are Hooks and how do I use them?",
    "hooks-answer": "If you’re familiar with {0} or other similar standards, you are already familiar with the concept of hooks. Hooks let the caller perform other actions in addition to the core logic of the method being called. In the case of ERC-777, a transfer hook can be used to call a method on a contract after transferring tokens to that contract.",
    "hooks-answer-rest": "<p> Umbra works similarly— when withdrawing funds from the contract— users might want to deposit them straight into a DeFi protocol or swap their DAI for ETH. Hooks let you do this. </p> <p>You’ll notice the Umbra contract exposes multiple withdraw methods. First we have:</p> <ol> <li><span class=\"code\">withdrawToken()</span> for standard withdrawals, i.e. simple transfers</li> <li> <span class=\"code\">withdrawTokenOnBehalf()</span> has the same functionality as <span class=\"code\">withdrawToken()</span>, but lets a relayer submit the withdraw on your behalf to support meta-transactions. </li> </ol> <p>Then we have the two hook methods:</p> <ol> <li> <span class=\"code\">withdrawTokenAndCall()</span> is analogous to <span class=\"code\">withdrawToken()</span>, but lets you pass in the address of a contract and the data to call on that contract. </li> <li> <span class=\"code\">withdrawTokenAndCallOnBehalf()</span> is analogous to <span class=\"code\">withdrawTokenOnBehalf()</span>, but also lets you pass in the address of a contract and the data to call on that contract. </li> </ol> <p> To use hooks, first you need to write and deploy a hook contract conforming to the <span class=\"code\">IUmbraHookReceiver</span> interface. This requires the contract to implement a method calls <span class=\"code\">tokensWithdrawn()</span> that takes a handful of parameters. The address of this contract would be passed as the value for the <span class=\"code\">_hook</span> input in the above methods. </p>",
    "hooks-answer-encode-data": "Then you need to encode the calldata that the hook contract will receive and can operate on. See the {0} section of the ethers.js docs for info on how to encode function data.",
    "hooks-answer-encoding-data": "Encoding Data",
    "hooks-answer-end": "<p> And that’s all there is to it. With the address of the hook contract and the encoded calldata, you are ready to call one of the two hook-based methods. </p>"
  },
  "AccountReceiveTable": {
    "processing-results": "Processing results...",
    "configure-umbra": "You won't be able to receive funds until you've configured Umbra.",
    "navigate-to-setup": "Please navigate to the {0} page and do so",
    "setup": "Setup",
    "keys-dont-match": "The stealth keys published for this account do not match those generated by it. Please navigate to the {0} page and complete the setup flow to ensure the keys published match this account. Failure to do so may result in payments sent to your account being difficult, or even impossible, to withdraw. ",
    "learn-more": "Learn more",
    "scan-settings": "Change scan settings",
    "account-empty": "This account has not received any funds",
    "received-funds": "Received Funds",
    "sender": "Sender",
    "stealth-receiver": "Stealth Receiver",
    "received": "Received",
    "withdrawn": "Withdrawn",
    "hide": "Hide",
    "withdraw": "Withdraw",
    "receiver": "Receiver",
    "scanning-complete": "Scanning completed successfully",
    "custom-prv-key": " with custom private key",
    "scanned-from-block": "Scanned from block",
    "to": "to",
    "all-blocks-scanned": "All blocks have been scanned",
    "scanned-all-blocks-up-to": "Scanned all blocks up to",
    "to-current-block": "to current block",
    "private-key-copied": "Private key copied to clipboard",
    "date-received": "Date Received",
    "amount": "Amount",
    "wallet-not-connected": "Wallet not connected. Try refreshing the page and connect your wallet",
    "address-copied": "address copied to clipboard",
    "umbra-instance-not-found": "Umbra instance not found",
    "provider-not-found": "Provider not found",
    "no-announcement-selected": "No announcement is selected for withdraw",
    "signer-or-provider-not-found": "Signer or provider not found",
    "fee-not-set": "Fee is not set",
    "invalid-chain-id": "Invalid chainID",
    "receiver-tool-tip": "The stealth address which received these funds. It looks like an empty address, and it can't be tied to your account, but only you have the ability to generate its private key."
  },
  "AccountReceiveTableWarning": {
    "withdrawal-warning": "You are withdrawing to {0}, which has the following warnings:",
    "withdrawal-warning-rest": "<span class=\"text-bold\">Continuing with withdrawal is not recommended</span> unless you know what you are doing, as this may reduce or entirely remove the privacy properties provided by Umbra.",
    "learn-more": "Learn More",
    "acknowledge-risks": "I acknowledge the risks"
  },
  "AccountReceiveTableWithdrawConfirmation": {
    "confirm": "Confirm",
    "cancel": "Cancel",
    "confirm-withdrawal": "Confirm Withdrawal",
    "to": "Withdrawing to",
    "amount": "Amount",
    "tx-fee": "Transaction Fee",
    "relayer-gas-fee": "Relayer Gas Fee",
    "you-will-receive": "You'll receive",
    "cannot-withdraw": "Cannot withdraw, please correct fee error",
    "withdraw-in-progress": "Withdraw in progress...",
    "view-transaction": "View transaction"
  },
  "Argent": {
    "warning": "Warning: Argent Compatibility Issues",
    "warning-paragraph": "<p class=\"text-bold\"> Umbra is not compatible with Argent's standard security model. While you can still use Umbra with Argent, you are at risk of losing funds if you switch devices or have to rely on social recovery without first withdrawing any funds sent to you via Umbra. </p> <p> Umbra works by generating app-specific keys derived from your wallet's private key. Argent is unique in that its security does not rely on your private key. This is good in many ways. </p> <p>When using Umbra, however, you must be aware of the following:</p> <ol> <li> If you recover your Argent wallet onto a new device, the new wallet will have the same address but a different private key. Unless you have access to the old device, funds sent via Umbra that you have not withdrawn will become unrecoverable. </li> <br /> <li> As a result, when you get a new device, you should withdraw all funds first using your old device, then repeat the Umbra account setup and re-publish your keys. Soon, the app will attempt to detect when you need to do this to minimize the chance of lost funds, but for now you must do it manually. </li> <br /> <li> Unlike other applications, the security of funds received by Umbra is not protected by the standard Argent security model, and instead they are just protected by your private key. </li> </ol>",
    "acknowledge-risks": "I acknowledge the risks"
  },
  "ConnectWalletCard": {
    "connect-wallet": "Connect Wallet"
  },
  "WithdrawForm": {
    "withdraw-address": "Enter address to withdraw funds to",
    "address": "Address",
    "fetching-fee-estimate": "Fetching fee estimate...",
    "withdrawal-fee": "Withdrawal fee:",
    "estimated-withdrawal-fee": "Estimated withdrawal fee:",
    "withdraw-in-progress": "Withdraw in progress...",
    "warning": " <span class=\"text-bold\">WARNING</span>: Be sure you understand the security implications before entering a withdrawal address. If you withdraw to an address publicly associated with you, privacy for this transaction will be lost.",
    "learn-more": "Learn more",
    "hide": "Hide",
    "show": "Show",
    "stealth-prv-key": "stealth address private key",
    "withdraw": "Withdraw",
    "enter-valid-address": "Please enter valid address"
  },
  "Utils": {
    "Alerts": {
      "transaction-pending": "Your transaction is pending",
      "transaction-succeeded": "Your transaction has succeeded",
      "transaction-failed": "Your transaction has failed"
    },
    "Address": {
      "name-publicly-viewable": "This name is publicly viewable",
      "name-resolves-to-ens": "This name resolves to the publicly viewable ENS name ",
      "name-resolves-to-cns": "This name resolves to the publicly viewable CNS name ",
      "it": "It",
      "resolves-to": "resolves to",
      "is": "is",
      "same-addr-as-wallet": "the same address as the connected wallet",
      "same-addr-as-stealth": "the same address as the stealth address",
      "address-it-resolves-to": "The address it resolves to",
      "has-poap-tokens": "has POAP tokens"
    }
  }
}
